/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package arihunta.wordgames

import java.nio.file.Files

fun main(args: Array<String>) {

    println("--------------------------------------------------")

    letterBoxed("LOI GNT SHC PAU")

    println("--------------------------------------------------")

    letterBoxed("CLT NHS APU FOE")

    println("--------------------------------------------------")

    letterBoxed("CXL OYT PNB IHE")

    println("--------------------------------------------------")

}

fun letterBoxed(input: String) {

    // load dictionary
    val dictionary: List<String> = Files::class.java.getResource("/words.txt").readText().split("\n").map { it.trim() }

    // pattern for words made up of the correct letters
    val allLetters = input.replace(" ", "").toLowerCase()

    // filter down the dictionary
    val wordsMadeOfLetters = dictionary.filter { it.matches(Regex("[$allLetters]+")) }

    val nextLetterMap: Map<Char, String> = mapOf(

            allLetters[0] to allLetters.substring(3, 12),
            allLetters[1] to allLetters.substring(3, 12),
            allLetters[2] to allLetters.substring(3, 12),
            allLetters[3] to "${allLetters.substring(0, 3)}${allLetters.substring(6, 12)}",
            allLetters[4] to "${allLetters.substring(0, 3)}${allLetters.substring(6, 12)}",
            allLetters[5] to "${allLetters.substring(0, 3)}${allLetters.substring(6, 12)}",
            allLetters[6] to "${allLetters.substring(0, 6)}${allLetters.substring(9, 12)}",
            allLetters[7] to "${allLetters.substring(0, 6)}${allLetters.substring(9, 12)}",
            allLetters[8] to "${allLetters.substring(0, 6)}${allLetters.substring(9, 12)}",
            allLetters[9] to allLetters.substring(0, 9),
            allLetters[10] to allLetters.substring(0, 9),
            allLetters[11] to allLetters.substring(0, 9)

    )

    val solutions = allLetters.map {
        solveLetterBoxedRecursive(listOf(), it.toString(), wordsMadeOfLetters, nextLetterMap, wordsMadeOfLetters, "")
    }.flatten()

}

fun solveLetterBoxedRecursive(previousWords: List<String>, currentString: String, filteredDictionary: List<String>, letterMap: Map<Char, String>, fullDictionary: List<String>, indent: String): List<List<String>> {

    // get all matches for this word
    val partialOrFullMatches = filteredDictionary.filter { it.startsWith(currentString) }.filter { it.length >= currentString.length }.filter { it != currentString }
    val fullMatches = filteredDictionary.filter { it == currentString }

    val retValFullMatch: List<List<String>>
    // we have found a whole word!
    if (fullMatches.size == 1) {

        // add it to the list
        val wordList = previousWords + currentString

        // we have a full solution, so return it and end this branch
        if (wordList.map { it.toCharArray().asList() }.flatten().toSet().size == 12) {
            println("${wordList.size}: $wordList")
            retValFullMatch = listOf(wordList)
        } else if (wordList.size == 2) {
            retValFullMatch = listOf()
        } else {
            // we don't have a solution yet, so dig deeper, starting a new word
            val firstLetter = currentString[currentString.length - 1].toString()
            retValFullMatch = solveLetterBoxedRecursive(wordList, firstLetter, fullDictionary, letterMap, fullDictionary, indent/* + "    "*/)
        }

    } else {
        retValFullMatch = listOf()
    }

    // we can continue with this word!
    val retValPartialMatch = if (!partialOrFullMatches.isEmpty()) {

        val possibleNextLetters = letterMap[currentString[currentString.length - 1]]!!

        possibleNextLetters.map { nextLetter ->
            solveLetterBoxedRecursive(previousWords, currentString + nextLetter, partialOrFullMatches, letterMap, fullDictionary, indent/* + "    "*/)
        }.flatten()

    } else {
        listOf()
    }

    return retValFullMatch + retValPartialMatch

}
